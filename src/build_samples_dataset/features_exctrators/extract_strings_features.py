import xml.etree.ElementTree as Et
import pandas as pd
import iocextract
import string
import re

from build_samples_dataset.features_exctrators import SUSPICIOUS_FUNCTIONS_INPUT

GLOBAL_DLL_LIBRARIES_PATH = '../../../resources/parsed_dll_libraries.csv'
KEYS_XML_PATH = '../../../resources/keys.xml'

PASSWORD_MANAGERS_NAMES_PATTERNS = [re.compile('keepass', re.IGNORECASE),
                                    re.compile('lastpass', re.IGNORECASE),
                                    re.compile('dashlane', re.IGNORECASE)]

PASSWORD_STRING_PATTERN = re.compile('password', re.IGNORECASE)
PASS_STRING_PATTERN = re.compile('pass', re.IGNORECASE)
MASTER_KEY_STRING_PATTERN = re.compile('masterkey', re.IGNORECASE)

DLL_IMPORTS_PATTERN = re.compile('\.dll$')


def parse_pe_strings(filename, min_length=4):
    with open(filename, errors="ignore") as f:
        result = ""
        for c in f.read():
            if c in string.printable:
                result += c
                continue
            if len(result) >= min_length:
                yield result
            result = ""
        if len(result) >= min_length:
            yield result


class ExtractFeaturesFromStrings:
    def __init__(self, sample_sha256, sample_path):
        self.listed_strings = list(parse_pe_strings(sample_path))
        self.unified_strings = "".join(curr_string for curr_string in self.listed_strings)
        self.sample_sha256 = sample_sha256

        # Initialize default value features
        self.strings_features = {
            'password_manager_name': False,
            'masterkey_counts': 0,
            'password_counts': 0,
            'pass_counts': 0,
            'keys_counts': 0,
            'strings_dll_imports': [],
            'strings_sus_functions': []
        }

    def extract(self):

        self.strings_features['password_manager_name'] = self.search_password_manager_name()
        self.strings_features['masterkey_counts'] = self.count_masterkey_substring()
        self.strings_features['password_counts'] = self.count_password_substring()
        self.strings_features['pass_counts'] = self.count_pass_substring()
        self.strings_features['keys_counts'] = self.count_keys()
        self.strings_features['strings_dll_imports'] = self.extract_dll_imports()
        self.strings_features['strings_sus_functions'] = self.extract_sus_functions_calls()

        return self.strings_features

    def search_password_manager_name(self) -> bool:
        for password_manager_name_pattern in PASSWORD_MANAGERS_NAMES_PATTERNS:
            if password_manager_name_pattern.search(self.unified_strings):

                return True

        return False

    def count_masterkey_substring(self) -> int:
        return len(re.findall(MASTER_KEY_STRING_PATTERN, self.unified_strings))

    def count_password_substring(self) -> int:
        return len(re.findall(PASSWORD_STRING_PATTERN, self.unified_strings))

    def count_pass_substring(self) -> int:
        return len(re.findall(PASS_STRING_PATTERN, self.unified_strings))

    def extract_dll_imports(self) -> list:
        global_dll_df = pd.read_csv(GLOBAL_DLL_LIBRARIES_PATH)
        global_dll_set = set(global_dll_df['dll_libraries'])

        import_libraries = []
        lowered_unified_strings = self.unified_strings.lower()
        for curr_dll in global_dll_set:
            if curr_dll in lowered_unified_strings:
                import_libraries.append(curr_dll)

        return import_libraries

    def extract_sus_functions_calls(self) -> list:
        sus_functions = []

        for sus_func in SUSPICIOUS_FUNCTIONS_INPUT:
            if sus_func in self.unified_strings:
                sus_functions.append(sus_func)

        return sus_functions

    def extract_obfuscated_urls(self) -> list:
        urls = list(iocextract.extract_urls(self.unified_strings, refang=True))
        encoded_urls = list(iocextract.extract_encoded_urls(self.unified_strings, refang=True))
        all_urls = list(set(urls).union(encoded_urls))

        return all_urls

    def extract_obfuscated_ips(self) -> int:
        return list(set(iocextract.extract_ips(self.unified_strings, refang=True)))

    def count_keys(self):
        keys_counter = 0
        keysXml = Et.parse(KEYS_XML_PATH).getroot()

        for r in keysXml.find('keys').findall('key'):
            if r.text in self.unified_strings:
                keys_counter += 1

        return keys_counter
